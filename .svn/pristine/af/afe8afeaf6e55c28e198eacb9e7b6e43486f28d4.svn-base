//
//  EspClock.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspClock.h"
#import "EspGridDefs.h"
#import <Foundation/Foundation.h>

@implementation EspClock
@synthesize peerList;
@synthesize udp;
@synthesize osc;
@synthesize syncModeName;
@synthesize adjustment;
@synthesize flux;
@synthesize fluxStatus;

struct timeval t;
EspTimeType EspGridTime(void) {
    gettimeofday(&t, NULL);
    return ((double)t.tv_sec) + (1.0E-6*(double)t.tv_usec);
}

-(id) init
{
    greatestShiftedClock0 = -9999999.0;
    greatestShiftedClock1 = -9999999.0;
    adjustmentInMode0 = 0.0;
    adjustmentInMode1 = 0.0;
    adjustmentInMode2 = 0.0;
    adjustment = 0.0;
    
    for(int x=0;x<1024;x++)
    {
        fluxTimes[x] = -100000.0;
        fluxValues[x] = 0.0;
    }
    fluxIndex = 0;
    [self setFluxStatus:@"---"];
    self = [super init];
    countOfBeaconsIssued = 0;
    [self changeSyncMode:1];
    [NSTimer scheduledTimerWithTimeInterval:5.000
                                     target:self
                                   selector:@selector(sendBeacon:)
                                   userInfo:nil
                                    repeats:YES];
    urgentBeaconCounter = 20;
    [self scheduleUrgentBeacon];
    return self;
}


-(void) changeSyncMode:(int)mode
{
    syncMode = mode;
    switch(syncMode) {
        case 0: [self setSyncModeName:@"simple race"]; break;
        case 1: [self setSyncModeName:@"race + Cristian adjustment"]; break;
        case 2: [self setSyncModeName:@"race + reference beacon"]; break;
    }
}

-(void) issueBeacon:(BOOL)urgent
{
    countOfBeaconsIssued++;
    NSString* l = [NSString stringWithFormat:@"sending BEACON (n = %u)]",countOfBeaconsIssued];
    postLog(l,self);
    NSMutableDictionary* d = [[NSMutableDictionary alloc] init]; // was autoreleased on OSX 0.48 ???
    [d setObject:[NSNumber numberWithLong:countOfBeaconsIssued] forKey:@"beaconCount"];
    [d setObject:[NSNumber numberWithDouble:EspGridTime()] forKey:@"beaconClock"];
    [d setObject:[NSNumber numberWithInt:ESPGRID_MAJORVERSION] forKey:@"majorVersion"];
    [d setObject:[NSNumber numberWithInt:ESPGRID_MINORVERSION] forKey:@"minorVersion"];
    [d setObject:[NSNumber numberWithInt:syncMode] forKey:@"syncMode"];
    [d setObject:[NSNumber numberWithBool:urgent] forKey:@"urgent"];
    [udp transmitOpcode:ESP_OPCODE_BEACON withDictionary:d];
    [peerList checkAllLastBeaconStatuses];
}

-(void) issueAck:(NSDictionary*)d
{
    NSMutableDictionary* d2 = [[NSMutableDictionary alloc] init];
    NSString* name = [d objectForKey:@"name"];
    NSString* machine = [d objectForKey:@"machine"];
    [d2 setValue:name forKey:@"nameRcvd"];
    [d2 setValue:machine forKey:@"machineRcvd"];
    [d2 setValue:[[d objectForKey:@"beaconCount"] copy] forKey:@"beaconCount"];
    [d2 setValue:[[d objectForKey:@"beaconClock"] copy] forKey:@"beaconClock"];
    [d2 setValue:[[d objectForKey:@"timeReceived"] copy] forKey:@"beaconReceived"];
    EspTimeType now = EspGridTime();
    [d2 setValue:[NSNumber numberWithDouble:now] forKey:@"rawClock"]; // was @"ackClock" recently
    [d2 setValue:[NSNumber numberWithDouble:now+adjustment] forKey:@"adjustedClock"]; // was @"clock" recently
    [d2 setValue:[[d objectForKey:@"ip"] copy] forKey:@"ipRcvd"];
    [d2 setObject:[NSNumber numberWithInt:ESPGRID_MAJORVERSION] forKey:@"majorVersion"];
    [d2 setObject:[NSNumber numberWithInt:ESPGRID_MINORVERSION] forKey:@"minorVersion"];
    NSString* l = [NSString stringWithFormat:@"sending ACK for %@-%@",name,machine];
    postLog(l, self);
    [udp transmitOpcode:ESP_OPCODE_ACK withDictionary:d2];
    
}

-(void) sendBeacon:(NSTimer*)t
{
    [self issueBeacon:NO];
}


-(void) urgentBeacon:(NSTimer*)t
{
    [self issueBeacon:YES];
    urgentBeaconCounter--;
    if(urgentBeaconCounter>0) [self scheduleUrgentBeacon];
}

-(void) scheduleUrgentBeacon
{
    [NSTimer scheduledTimerWithTimeInterval:0.025
                                     target:self
                                   selector:@selector(urgentBeacon:)
                                   userInfo:nil
                                    repeats:NO];
}

-(EspTimeType) convertToMachineTime:(EspTimeType)t
{   // convert logical time to EspGridTime()
    return t - adjustment;
}

-(EspTimeType) convertToGridTime:(EspTimeType)t
{   // convert EspGridTime() to logical time
    return t + adjustment;
}

-(EspTimeType) currentAdjustedTime
{
    return EspGridTime() + adjustment;
}

-(BOOL) handleOpcode:(NSDictionary*)d;
{
    id opcodeObject = [d objectForKey:@"opcode"];
    if(opcodeObject == nil) { postWarning(@"asked to handle opcode without opcode field",self); return NO; }
    if(![opcodeObject isKindOfClass:[NSNumber class]]) { postWarning(@"opcode field not number",self); return NO; }
    int opcode = [opcodeObject intValue];
        
    if(opcode==ESP_OPCODE_BEACON) {
        
        // validate opcode fields
        NSString* name = [d objectForKey:@"name"]; VALIDATE_OPCODE_NSSTRING(name);
        NSString* machine = [d objectForKey:@"machine"]; VALIDATE_OPCODE_NSSTRING(machine);
        NSString* ip = [d objectForKey:@"ip"]; VALIDATE_OPCODE_NSSTRING(ip);
        BOOL urgent = [[d objectForKey:@"urgent"] boolValue]; // no need to validate: defaults to FALSE which is okay
        NSNumber* majorVersion = [d objectForKey:@"majorVersion"]; VALIDATE_OPCODE_NSNUMBER(majorVersion);
        NSNumber* minorVersion = [d objectForKey:@"minorVersion"]; VALIDATE_OPCODE_NSNUMBER(minorVersion);
        NSNumber* timeReceived = [d objectForKey:@"timeReceived"]; VALIDATE_OPCODE_NSNUMBER(timeReceived);
        NSNumber* beaconCount = [d objectForKey:@"beaconCount"]; VALIDATE_OPCODE_NSNUMBER(beaconCount);
        NSNumber* beaconClock = [d objectForKey:@"beaconClock"]; VALIDATE_OPCODE_NSNUMBER(beaconClock);
        NSNumber* syncModeObject = [d objectForKey:@"syncMode"]; VALIDATE_OPCODE_NSNUMBER(syncModeObject);
        
        // post log message
        NSString* l;
        l = [NSString stringWithFormat:@"BEACON from %@-%@ at %@ running %@.%@",name,machine,ip,majorVersion,minorVersion];
        postLog(l, self);
        
        // harvest information into peerlist
        [peerList receivedBeacon:d];
                    
        // post a notification if urgent beacon to trigger KeyValueController rebroadcasts
        // this gives new peers ongoing beat information, etc, immediately. in the future,
        // it would probably be smarter to make new peers request KVC info until they get it from someone
        if(urgent)[[NSNotificationCenter defaultCenter] postNotificationName:@"newPeer" object:nil userInfo:nil];
        
        [self issueAck:d];
        
        return YES;
    }
    
    if(opcode==ESP_OPCODE_ACK) {
        
        // validate opcode fields
        NSString* name = [d objectForKey:@"name"]; VALIDATE_OPCODE_NSSTRING(name);
        NSString* machine = [d objectForKey:@"machine"]; VALIDATE_OPCODE_NSSTRING(machine);
        NSString* ip = [d objectForKey:@"ip"]; VALIDATE_OPCODE_NSSTRING(ip);
        NSString* nameRcvd = [d objectForKey:@"nameRcvd"]; VALIDATE_OPCODE_NSSTRING(nameRcvd);
        NSString* machineRcvd = [d objectForKey:@"machineRcvd"]; VALIDATE_OPCODE_NSSTRING(machineRcvd);
        NSNumber* beaconCountObject = [d objectForKey:@"beaconCount"]; VALIDATE_OPCODE_NSNUMBER(beaconCountObject);
        NSNumber* beaconClock = [d objectForKey:@"beaconClock"]; VALIDATE_OPCODE_NSNUMBER(beaconClock);
        NSNumber* beaconReceived = [d objectForKey:@"beaconReceived"]; VALIDATE_OPCODE_NSNUMBER(beaconReceived);
        NSNumber* rawClock = [d objectForKey:@"rawClock"]; VALIDATE_OPCODE_NSNUMBER(rawClock);
        NSNumber* adjustedClock = [d objectForKey:@"adjustedClock"]; VALIDATE_OPCODE_NSNUMBER(adjustedClock);
        NSNumber* timeReceived = [d objectForKey:@"timeReceived"]; VALIDATE_OPCODE_NSNUMBER(timeReceived);
        NSString* ipRcvd = [d objectForKey:@"ipRcvd"]; VALIDATE_OPCODE_NSSTRING(ipRcvd);
        NSNumber* majorVersion = [d objectForKey:@"majorVersion"]; VALIDATE_OPCODE_NSNUMBER(majorVersion);
        NSNumber* minorVersion = [d objectForKey:@"minorVersion"]; VALIDATE_OPCODE_NSNUMBER(minorVersion);

        // post log message
        NSString* l = [NSString stringWithFormat:@"receiving ACK from %@-%@ for %@-%@",name,machine,nameRcvd,machineRcvd];
        postLog(l,self);
        
        // harvest data into peerlist
        [peerList receivedAck:d];
        
        // determine mode 0 clock delta
        EspTimeType deltaMode0 = 0.0;
        EspTimeType shiftedClock = [adjustedClock doubleValue] - [timeReceived doubleValue];
        if(shiftedClock > greatestShiftedClock0)
        {
            greatestShiftedClock0 = shiftedClock;
            EspTimeType now = EspGridTime();
            EspTimeType unshiftedClock = shiftedClock + now;
            EspTimeType mode0now = now + adjustmentInMode0;
            if(mode0now < unshiftedClock) deltaMode0 = unshiftedClock - mode0now;
        }
        
        // determine mode 1 clock delta (with latency adjustment)
        EspTimeType deltaMode1 = 0.0;
        EspTimeType latency = [peerList latencyForName:name andMachine:machine];
        if(latency <= 0.5) shiftedClock += latency * 0.5; // only adjust for latencies less than 0.5 seconds
        if(shiftedClock > greatestShiftedClock1)
        {
            greatestShiftedClock1 = shiftedClock;
            EspTimeType now = EspGridTime();
            EspTimeType unshiftedClock = shiftedClock + now;
            EspTimeType mode1now = now + adjustmentInMode1;
            if(mode1now < unshiftedClock) deltaMode1 = unshiftedClock - mode1now;
        }
        
        // determine mode 2 clock delta (reference beacon adjustment)
        EspTimeType deltaMode2 = 0.0;
        if([peerList peerCount] > 2)
        {
            EspTimeType referenceBeaconShift = [peerList referenceBeaconDifferenceForName:name andMachine:machine];
            if(referenceBeaconShift != -100000.0)
            {
                EspTimeType sendersAdjustmentShifted = [adjustedClock doubleValue] - [rawClock doubleValue] + referenceBeaconShift;
                if(sendersAdjustmentShifted > adjustmentInMode2 ) deltaMode2 = sendersAdjustmentShifted - adjustmentInMode2;
                NSLog(@" mode 2: referenceBeaconShift=%f  sendersAdjustment=%f adjustment(old)=%f",sendersAdjustmentShifted,referenceBeaconShift,adjustmentInMode2);
            }
        }
        
        adjustmentInMode0 = adjustmentInMode0 + deltaMode0;
        adjustmentInMode1 = adjustmentInMode1 + deltaMode1;
        adjustmentInMode2 = adjustmentInMode2 + deltaMode2;
        
        NSLog(@" mode = %d",syncMode);
        NSLog(@" deltaMode0=%f  deltaMode1=%f  deltaMode2=%f",deltaMode0,deltaMode1,deltaMode2);
        NSLog(@" adjustMode0=%f adjustMode1=%f adjustMode2=%f",adjustmentInMode0,adjustmentInMode1,adjustmentInMode2);
        
        if(syncMode == 0)
        {
            adjustment = adjustmentInMode0;
            [self updateflux:deltaMode0];
        }
        else if(syncMode==1)
        {
            adjustment = adjustmentInMode1;
            [self updateflux:deltaMode1];
        }
        else if(syncMode==2)
        {
            if([peerList peerCount]>2)
            {
                adjustment = adjustmentInMode2;
                [self updateflux:deltaMode2];
            }
            else
            {
                adjustment = adjustmentInMode1;
                [self updateflux:deltaMode1];
            }
        }
                
        return YES;
    }
    
    return NO;
}


-(void)updateflux:(EspTimeType)adjToAdj
{
    EspTimeType now = EspGridTime();
    fluxTimes[fluxIndex] = now;
    fluxValues[fluxIndex] = fabs(adjToAdj);
    fluxIndex++;
    if(fluxIndex>=1024)fluxIndex=0;
    EspTimeType total = 0.0;
    EspTimeType threshold = now - 5.0;
    for(int x=0;x<1024;x++)if(fluxTimes[x]>threshold)total = total + fluxValues[x];
    [self setValue:[NSNumber numberWithDouble:total] forKey:@"flux"];
    NSLog(@"flux = %f",flux);
    if(flux > 1.0) [self setFluxStatus:@"UNSTABLE"];
    else if(flux==0.0) [self setFluxStatus:@"stable"];
    else
    {
        [self setFluxStatus:[NSString stringWithFormat:@"%.6f ms",flux*1000.0]];
    }
}

@end
